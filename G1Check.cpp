#include "G1Check.h"
#include "NPRSettings.h"
#include "AutogeneratedContractions_WithG1_WithSubtractions.h"

using namespace std;

// at lowest order, G1 has the spin - color structure
// 4 * (          [gamma_mu (1-gamma_5) T^a] (X) [gamma_mu T^a]
//       -(1/q^2) [qslash   (1-gamma_5) T^a] (X) [qslash   T^a] )
// where T^a (X) T^a = (1/2)(color mixed) - (1/6)(color diag)
DoubleWilsonMatrix BuildLowestOrderG1TensorStructure(const double q[4], double qsq, Parity parity)
{
    DoubleWilsonMatrix lowest_order_F1;
    for (int mu = 0; mu < 4; ++mu) {
	SpinMatrix V = SpinMatrix::Gamma(mu);
	SpinMatrix A = SpinMatrix::GammaMuGamma5(mu);
	SpinMatrix L = (parity == POSITIVE_PARITY ? V : (-1.0) * A);
	lowest_order_F1 +=
	    2.0 * DoubleWilsonMatrix::Construct(L, V, COLOR_STRUCTURE_MIXED)
	    - (2.0 / 3.0) * DoubleWilsonMatrix::Construct(L, V, COLOR_STRUCTURE_DIAGONAL);
    }
    SpinMatrix qslash = SpinMatrix::Slash(q);
    SpinMatrix qslashL;
    if (parity == POSITIVE_PARITY) qslashL = SpinMatrix::Slash(q);
    else qslashL = (-1.0) * SpinMatrix::Slash(q) * SpinMatrix::Gamma5();
    DoubleWilsonMatrix lowest_order_G1 = lowest_order_F1
	- (2.0 / qsq) * DoubleWilsonMatrix::Construct(qslashL, qslash, COLOR_STRUCTURE_MIXED)
	+ (2.0 / (3.0 * qsq)) * DoubleWilsonMatrix::Construct(qslashL, qslash, COLOR_STRUCTURE_DIAGONAL);

    return lowest_order_G1;
}


array<complex<double>, 8> ComputeTreeLevelG1ProjectedGreensFuncs(const NPRSettings &sett)
{
    DoubleWilsonMatrix lowest_order_G1 = BuildLowestOrderG1TensorStructure(sett.q, sett.qsq, sett.parity);

    array<complex<double>, 7> tree_level_G1_projected_greens_funcs;
    complex<double> tree_level_G1_HF_greens_func;
    if (sett.scheme == SchemeGammaMu) {
        tree_level_G1_projected_greens_funcs = ContractionsWithG1::DoContractionsTwoQuarkOpFourQuarkExt(lowest_order_G1, sett.projector_spin_color_structures);
    } else { // scheme == SchemeQslash
        tree_level_G1_projected_greens_funcs = ContractionsWithG1::DoQslashContractionsTwoQuarkOpFourQuarkExt(lowest_order_G1, sett.projector_spin_color_structures);
    }
    tree_level_G1_HF_greens_func = ContractionsWithG1::DoContractionTwoQuarkOpHFExt(lowest_order_G1, sett.HF_projector_spin_color_structure);
    
    array<complex<double>, 8> ret;
    for (int ext = 0; ext < 7; ++ext) {
	ret[ext] = tree_level_G1_projected_greens_funcs[ext];
    }
    ret[7] = tree_level_G1_HF_greens_func;
    return ret;
}


void CheckG1TreeLevelProjectedGreensFunctions(const NPRSettings &sett)
{
    array<complex<double>, 8> tree_level_proj_G1 = ComputeTreeLevelG1ProjectedGreensFuncs(sett);

    for (int ext = 0; ext < 8; ++ext) {
        printf("External state %d: computed tree level G1 = %f + i %f ; sett.tree_level_greens_func = %f + i %f\n",
                ext, tree_level_proj_G1[ext].real(), tree_level_proj_G1[ext].imag(),
                sett.tree_level_greens_funcs_8x8[7][ext].real(), sett.tree_level_greens_funcs_8x8[7][ext].imag());
        assert(abs(tree_level_proj_G1[ext] - sett.tree_level_greens_funcs_8x8[7][ext]) < 1e-12);
    }
    printf("passed test of tree level projected Green's functions of G1!\n");
}
