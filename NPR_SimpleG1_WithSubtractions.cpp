#include "NPR_SimpleG1_WithSubtractions.h"

#include "DoubleWilsonMatrix.h"
#include "util.h"
#include "NPR_Utils.h"
#include "A0.h"

#include "AutogeneratedContractions_WithG1_WithSubtractions.h"

using namespace std;

static const vector<int> non_8_1_operators { 0,   // Q'_1  (27,1)
                                             5,   // Q'_7  (8,8)
                                             6 }; // Q'_8  (8,8)

static void ComputeExternalLegsJackknife(
        JackknifeDatabase<WilsonMatrix> &jack_prop1,
        JackknifeDatabase<WilsonMatrix> &jack_prop2,
        const NPRSettings &sett)
{
    // Load external legs
    printf("loading external legs...\n");
    char prop1_format[512];
    char prop2_format[512];
    sprintf(prop1_format, "%s/external_leg_p%d_%d_%d_%d_traj%%d.dat", sett.dir, sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3]);
    sprintf(prop2_format, "%s/external_leg_p%d_%d_%d_%d_traj%%d.dat", sett.dir, sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);

    ConfSampleDatabase<WilsonMatrix> prop1_db = ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(prop1_format), sett.confs, sett.bin_size);
    ConfSampleDatabase<WilsonMatrix> prop2_db = ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(prop2_format), sett.confs, sett.bin_size);

    printf("doing external leg jackknife...\n");
    jack_prop1.Resize(sett.Njack);
    jack_prop2.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const vector<int> &sample = sett.jackknife_samples[jack];
	jack_prop1[jack] = prop1_db.MeanOnSample(sample);
	jack_prop2[jack] = prop2_db.MeanOnSample(sample);
    }
    printf("done external legs\n");
}

static JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> ComputeAmputatedFourqOpFourqDiagrams(
        const JackknifeDatabase<WilsonMatrix> &jack_prop1,
        const JackknifeDatabase<WilsonMatrix> &jack_prop2,
        const NPRSettings &sett)
{
    // Load unamputated VA diagrams
    printf("loading VA fourq diagrams (and computing LR diagrams)...\n");
    array<array<ConfSampleDatabase<DoubleWilsonMatrix>, 4>, 6> unamputated_fourq_LR_diagram_dbs;
    for (int diagram = 0; diagram < 6; ++diagram) {
	array<ConfSampleDatabase<DoubleWilsonMatrix>, 4> unamputated_fourq_VA_diagram_dbs;
	for (int va = 0; va < 4; ++va) {
	    char fourq_diagram_format[512];
	    sprintf(fourq_diagram_format, "%s/fourq_%s_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
		sett.dir, diagram_names[diagram], VA_names[va], sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	    unamputated_fourq_VA_diagram_dbs[va] =
		ConfSampleDatabase<DoubleWilsonMatrix>::LoadBinned(BinningDoubleWilsonMatrixLoader(fourq_diagram_format), sett.confs, sett.bin_size);
	}
	unamputated_fourq_LR_diagram_dbs[diagram] = MakeLRDiagrams<DoubleWilsonMatrix>(unamputated_fourq_VA_diagram_dbs, sett.parity);
    }

    if (!sett.do_disconnected) {
	printf("do_disconnected is FALSE, so zeroing disconnected diagrams\n");
	for (int diagram = 0; diagram < 6; ++diagram) {
	    if (diagram == FULLY_CONNECTED_COLOR_DIAG || diagram == FULLY_CONNECTED_COLOR_MIXED) continue;
	    for (int lr = 0; lr < 4; ++lr) {
		Zero(unamputated_fourq_LR_diagram_dbs[diagram][lr]);
	    }
	}
    }

    printf("amputating fourq diagrams of basic four-quark operators...\n");
    JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> jack_amputated_fourq_LR_diagrams;
    jack_amputated_fourq_LR_diagrams.Resize(sett.Njack);
    //printf("WARNING: NON PARALLEL FOR!\n");
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const vector<int> &sample = sett.jackknife_samples[jack];
	const WilsonMatrix &prop1 = jack_prop1[jack];
	const WilsonMatrix &prop2 = jack_prop2[jack];
        
	// Amputate the four-quark diagrams of the basic four-quark operators
	array<array<DoubleWilsonMatrix, 4>, 6> amputated_fourq_LR_diagrams;
	for (int diagram = 0; diagram < 6; ++diagram) {
	    for (int lr = 0; lr < 4; ++lr) {
		DoubleWilsonMatrix unamputated_diagram = unamputated_fourq_LR_diagram_dbs[diagram][lr].MeanOnSample(sample);
		amputated_fourq_LR_diagrams[diagram][lr] = Amputate(unamputated_diagram, prop1, prop2, prop1, prop2);
	    }
	}
        jack_amputated_fourq_LR_diagrams[jack] = amputated_fourq_LR_diagrams;
    }
    printf("done amputating fourq diagrams of basic four-quark operators.\n");

    return jack_amputated_fourq_LR_diagrams;
}

static JackknifeDatabase<DoubleWilsonMatrix> ComputeAmputatedG1FourqDiagrams(
        const JackknifeDatabase<WilsonMatrix> &jack_prop1,
        const JackknifeDatabase<WilsonMatrix> &jack_prop2,
        const NPRSettings &sett)
{
    printf("loading fourq G1 diagrams...\n");
    //const char* gammaAs[] = { "V", "A" };
    array<ConfSampleDatabase<DoubleWilsonMatrix>, 2> unamputated_fourq_VA_G1_dbs;
    array<ConfSampleDatabase<WilsonMatrix>, 2> unamputated_twoq_VA_G1_dbs;
    for (int va = 0; va < 2; ++va) {
	char fourq_diagram_format[512];
	//sprintf(fourq_diagram_format, "%s/fourq_G1%s_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
	//    dir, pc_str, gammaAs[va], mom1[0], mom1[1], mom1[2], mom1[3], mom2[0], mom2[1], mom2[2], mom2[3]);
	if (va == 0) {
	    sprintf(fourq_diagram_format, "%s/fourq_old_G1%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
	        sett.sub_dir, sett.c1_str, sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	} else {
	    sprintf(fourq_diagram_format, "%s/fourq_old_G1g5%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
	        sett.sub_dir, sett.c1_str, sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	}
	unamputated_fourq_VA_G1_dbs[va] =
	    ConfSampleDatabase<DoubleWilsonMatrix>::LoadBinned(BinningDoubleWilsonMatrixLoader(fourq_diagram_format), sett.confs, sett.bin_size);
    }
    ConfSampleDatabase<DoubleWilsonMatrix> unamputated_fourq_LR_G1_db =
	MakeLeftHandedDiagrams<DoubleWilsonMatrix>(unamputated_fourq_VA_G1_dbs, sett.parity);
    

    printf("amputating fourq diagrams of G1...\n");
    JackknifeDatabase<DoubleWilsonMatrix> jack_amputated_fourq_LR_G1_diagram;
    jack_amputated_fourq_LR_G1_diagram.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const vector<int> &sample = sett.jackknife_samples[jack];
	const WilsonMatrix &prop1 = jack_prop1[jack];
	const WilsonMatrix &prop2 = jack_prop2[jack];

	// Amputate the four-quark diagram of G1
	jack_amputated_fourq_LR_G1_diagram[jack] = Amputate(unamputated_fourq_LR_G1_db.MeanOnSample(sample), prop1, prop2, prop1, prop2);
    }
    printf("done amputating fourq diagrams of G1...\n");

    return jack_amputated_fourq_LR_G1_diagram;
}

static JackknifeDatabase<Matrix<complex<double>, 7>> ComputeProjectedGreensFuncsJackknife7x7(
        const JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> &jack_amputated_fourq_LR_diagrams,
        const NPRSettings &sett)
{
    printf("computing 7x7 projected four-quark Green's functions of unsubtracted operators...\n");
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_unsubtracted_fourq_greens_funcs_7x7;
    jack_unsubtracted_fourq_greens_funcs_7x7.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const array<array<DoubleWilsonMatrix, 4>, 6> &amputated_fourq_LR_diagrams = jack_amputated_fourq_LR_diagrams[jack];
	if (sett.scheme == SchemeGammaMu) {
	    jack_unsubtracted_fourq_greens_funcs_7x7[jack] =
		ContractionsWithG1::DoContractionsFourQuarkOpFourQuarkExt(amputated_fourq_LR_diagrams, sett.projector_spin_color_structures);
	} else { // scheme == SchemeQslash
	    jack_unsubtracted_fourq_greens_funcs_7x7[jack] =
		ContractionsWithG1::DoQslashContractionsFourQuarkOpFourQuarkExt(amputated_fourq_LR_diagrams, sett.projector_spin_color_structures);
	}
    }
    printf("done computing 7x7 projected four-quark Green's functions of unsubtracted operators\n");

    return jack_unsubtracted_fourq_greens_funcs_7x7;
}

static JackknifeDatabase<array<complex<double>, 7>> ComputeProjectedHFGreensFuncsJackknife(
        const JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> &jack_amputated_fourq_LR_diagrams,
        const NPRSettings &sett)
{
    printf("computing projected Green's funcs of 7 four-quark operators in HF external state...\n");
    JackknifeDatabase<array<complex<double>, 7>> jack_unsubtracted_fourq_HF_greens_funcs;
    jack_unsubtracted_fourq_HF_greens_funcs.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const array<array<DoubleWilsonMatrix, 4>, 6> &amputated_fourq_LR_diagrams = jack_amputated_fourq_LR_diagrams[jack];

	jack_unsubtracted_fourq_HF_greens_funcs[jack] =
	    ContractionsWithG1::DoContractionsFourQuarkOpHFExt(amputated_fourq_LR_diagrams, sett.HF_projector_spin_color_structure);

        // in Qslash scheme, we only look at mixing between G1 and (8,1) operators.
        // So zero out the HF greens functions of (27,1) and (8,8) operators:
        if (sett.scheme == SchemeQslash) {
            for (int op : non_8_1_operators) {
	        jack_unsubtracted_fourq_HF_greens_funcs[jack][op] = 0;
            }
        }
    }
    printf("done computing projected Green's funcs of 7 four-quark operators in HF external state.\n");

    return jack_unsubtracted_fourq_HF_greens_funcs;
}

static JackknifeDatabase<array<complex<double>, 8>> ComputeProjectedG1GreensFuncs(
        const JackknifeDatabase<DoubleWilsonMatrix> &jack_amputated_fourq_LR_G1_diagram,
        const NPRSettings &sett)
{
    printf("computing projected Green's functions of G1 in all 8 external states...\n");
    JackknifeDatabase<array<complex<double>, 8>> jack_unsubtracted_projected_G1_greens_funcs;
    jack_unsubtracted_projected_G1_greens_funcs.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const DoubleWilsonMatrix &amputated_fourq_LR_G1_diagram = jack_amputated_fourq_LR_G1_diagram[jack];

	array<complex<double>, 7> projected_unsubtracted_G1_fourq_greens_funcs;
	if (sett.scheme == SchemeGammaMu) {
	    projected_unsubtracted_G1_fourq_greens_funcs =
		ContractionsWithG1::DoContractionsTwoQuarkOpFourQuarkExt(amputated_fourq_LR_G1_diagram, sett.projector_spin_color_structures);
	} else { // scheme == SchemeQslash
	    projected_unsubtracted_G1_fourq_greens_funcs =
		ContractionsWithG1::DoQslashContractionsTwoQuarkOpFourQuarkExt(amputated_fourq_LR_G1_diagram, sett.projector_spin_color_structures);
	}
	complex<double> projected_unsubtracted_G1_fourq_HF_greens_func =
	    ContractionsWithG1::DoContractionTwoQuarkOpHFExt(amputated_fourq_LR_G1_diagram, sett.HF_projector_spin_color_structure);

        for (int ext = 0; ext < 7; ++ext) {
            jack_unsubtracted_projected_G1_greens_funcs[jack][ext] = projected_unsubtracted_G1_fourq_greens_funcs[ext];
        }
        jack_unsubtracted_projected_G1_greens_funcs[jack][7] = projected_unsubtracted_G1_fourq_HF_greens_func;
    }
    printf("done computing projected Green's functions of G1 in all 8 external states.\n");

    return jack_unsubtracted_projected_G1_greens_funcs;
}




static JackknifeDatabase<Matrix<complex<double>, 8>> CombineProjectedGreensFuncsJackknife8x8(
        const JackknifeDatabase<Matrix<complex<double>, 7>> &jack_unsubtracted_fourq_greens_funcs_7x7,
        const JackknifeDatabase<array<complex<double>, 7>> &jack_unsubtracted_fourq_HF_greens_funcs,
        const JackknifeDatabase<array<complex<double>, 8>> &jack_unsubtracted_projected_G1_greens_funcs,
        const NPRSettings &sett)
{

    printf("combining all projected Green's functions into an 8x8 matrix...\n");
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8;
    jack_unsubtracted_fourq_greens_funcs_8x8.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const Matrix<complex<double>, 7> &projected_unsubtracted_chiral_fourq_greens_funcs = jack_unsubtracted_fourq_greens_funcs_7x7[jack];
	const array<complex<double>, 7> &projected_unsubtracted_chiral_fourq_HF_greens_funcs = jack_unsubtracted_fourq_HF_greens_funcs[jack];
	const array<complex<double>, 8> &projected_unsubtracted_G1_fourq_greens_funcs = jack_unsubtracted_projected_G1_greens_funcs[jack];

	// Combine all the projected four-quark Green's functions of the four-quark operators
	// and G1 into one big 8x8 matrix
	Matrix<complex<double>, 8> projected_unsubtracted_greens_funcs_8x8;
	for (int op = 0; op < 7; ++op) {
	    for (int ext = 0; ext < 7; ++ext) {
		projected_unsubtracted_greens_funcs_8x8[op][ext] = projected_unsubtracted_chiral_fourq_greens_funcs[op][ext];
	    }
	}
	for (int op = 0; op < 7; ++op) {
	    projected_unsubtracted_greens_funcs_8x8[op][7] = projected_unsubtracted_chiral_fourq_HF_greens_funcs[op];
	}
	for (int ext = 0; ext < 8; ++ext) {
	    projected_unsubtracted_greens_funcs_8x8[7][ext] = projected_unsubtracted_G1_fourq_greens_funcs[ext];
	}

	// optionally, manually set the imaginary parts of all Green's functions to zero
	if (sett.enforce_reality) {
	    ZeroOutImaginaryPart(projected_unsubtracted_greens_funcs_8x8);
	}

	jack_unsubtracted_fourq_greens_funcs_8x8[jack] = projected_unsubtracted_greens_funcs_8x8;
    }
    printf("combining all projected Green's functions into an 8x8 matrix...\n");

    PrintRealPartMatrixWithError("real part of unsubtracted projected fourq greens functions", jack_unsubtracted_fourq_greens_funcs_8x8);
    PrintImaginaryPartMatrixWithError("imaginary part of unsubtracted projected fourq greens functions", jack_unsubtracted_fourq_greens_funcs_8x8);

    return jack_unsubtracted_fourq_greens_funcs_8x8;
}

static array<array<JackknifeDatabase<complex<double>>, Nsub>, 8> ComputeSubtractionCoefficientsJackknife(
        const JackknifeDatabase<WilsonMatrix> &jack_prop1,
        const JackknifeDatabase<WilsonMatrix> &jack_prop2,
        const NPRSettings &sett)
{
    printf("loading VA twoq diagrams (and computing LR diagrams)...\n");
    array<array<ConfSampleDatabase<WilsonMatrix>, 4>, 6> unamputated_twoq_LR_diagram_dbs;
    for (int diagram = 2 /* fully connected doesn't have twoq diagrams */; diagram < 6; ++diagram) {
	array<ConfSampleDatabase<WilsonMatrix>, 4> unamputated_twoq_VA_diagram_dbs;
	for (int va = 0; va < 4; ++va) {
	    char twoq_diagram_format[512];
	    sprintf(twoq_diagram_format, "%s/twoq_%s_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
		sett.dir, diagram_names[diagram], VA_names[va], sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	    unamputated_twoq_VA_diagram_dbs[va] =
		ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(twoq_diagram_format), sett.confs, sett.bin_size);
	}
	unamputated_twoq_LR_diagram_dbs[diagram] = MakeLRDiagrams<WilsonMatrix>(unamputated_twoq_VA_diagram_dbs, sett.parity);
    }

    printf("loading twoq subtraction diagrams (Nsub = %d)...\n", Nsub);
    array<ConfSampleDatabase<WilsonMatrix>, Nsub> unamputated_twoq_subtraction_dbs;
    for (int sub = 0; sub < Nsub; ++sub) {
	char twoq_diagram_format[512];
	sprintf(twoq_diagram_format, "%s/twoq_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
	    sett.sub_dir, sett.subtraction_op_names[sub], sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	unamputated_twoq_subtraction_dbs[sub] =
	    ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(twoq_diagram_format), sett.confs, sett.bin_size);
    }

    printf("loading twoq G1 diagrams...\n");
    //const char* gammaAs[] = { "V", "A" };
    array<ConfSampleDatabase<WilsonMatrix>, 2> unamputated_twoq_VA_G1_dbs;
    for (int va = 0; va < 2; ++va) {
	char twoq_diagram_format[512];
	//sprintf(twoq_diagram_format, "%s/twoq_G1%s_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
	//    dir, pc_str, gammaAs[va], mom1[0], mom1[1], mom1[2], mom1[3], mom2[0], mom2[1], mom2[2], mom2[3]);
	if (va == 0) {
	    sprintf(twoq_diagram_format, "%s/twoq_old_G1%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
	        sett.sub_dir, sett.c1_str, sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	} else {
	    sprintf(twoq_diagram_format, "%s/twoq_old_G1g5%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
	        sett.sub_dir, sett.c1_str, sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	}
	unamputated_twoq_VA_G1_dbs[va] = ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(twoq_diagram_format), sett.confs, sett.bin_size);
    }
    ConfSampleDatabase<WilsonMatrix> unamputated_twoq_LR_G1_db =
	MakeLeftHandedDiagrams<WilsonMatrix>(unamputated_twoq_VA_G1_dbs, sett.parity);


    printf("computing subtraction coefficients...\n");
    array<array<JackknifeDatabase<complex<double>>, Nsub>, 8> jack_subtraction_coefficients;
    array<JackknifeDatabase<SpinMatrix>, 8> jack_unsubtracted_chiral_twoq_greens_funcs;
    array<JackknifeDatabase<SpinMatrix>, 8> jack_subtracted_chiral_twoq_greens_funcs;
    for (int op = 0; op < 8; ++op) {
	jack_unsubtracted_chiral_twoq_greens_funcs[op].Resize(sett.Njack);
	jack_subtracted_chiral_twoq_greens_funcs[op].Resize(sett.Njack);
	for (int sub = 0; sub < Nsub; ++sub) {
	    jack_subtraction_coefficients[op][sub].Resize(sett.Njack);
	}
    }
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const vector<int> &sample = sett.jackknife_samples[jack];
	const WilsonMatrix &prop1 = jack_prop1[jack];
	const WilsonMatrix &prop2 = jack_prop2[jack];
        
	// Amputate the two-quark diagrams of the basic four-quark operators
	array<array<WilsonMatrix, 4>, 6> amputated_twoq_LR_diagrams;
	for (int diagram = 2 /*note*/; diagram < 6; ++diagram) {
	    for (int lr = 0; lr < 4; ++lr) {
		WilsonMatrix unamputated_diagram = unamputated_twoq_LR_diagram_dbs[diagram][lr].MeanOnSample(sample);
		amputated_twoq_LR_diagrams[diagram][lr] = Amputate(unamputated_diagram, prop1, prop2);
	    }
	}
	// Combine the diagrams of the basic operators to get the two-quark Green's
	// functions of the chiral basis four-quark operators
	array<WilsonMatrix, 7> unsubtracted_chiral_twoq_greens_funcs =
	    ContractionsWithG1::DoContractionsFourQuarkOpTwoQuarkExt(amputated_twoq_LR_diagrams);

	// Amputate the two-quark diagram of G1
	WilsonMatrix amputated_twoq_G1_diagram = Amputate(unamputated_twoq_LR_G1_db.MeanOnSample(sample), prop1, prop2);
	// two-quark Green's function of G1 has only the one diagram which we already have

	// Amputate the two-quark diagrams of the subtraction operators
	array<WilsonMatrix, Nsub> amputated_twoq_subtraction_diagrams;
	for (int sub = 0; sub < Nsub; ++sub) {
	    WilsonMatrix unamputated_twoq_diagram = unamputated_twoq_subtraction_dbs[sub].MeanOnSample(sample);
	    amputated_twoq_subtraction_diagrams[sub] = Amputate(unamputated_twoq_diagram, prop1, prop2);
	}

	// Compute subtraction coefficients for the chiral-basis four-quark operators
	array<array<complex<double>, Nsub>, 8> subtraction_coefficients;
	for (int op = 0; op < 7; ++op) {
	    subtraction_coefficients[op] = ComputeSubtractionCoefficients(unsubtracted_chiral_twoq_greens_funcs[op],
		amputated_twoq_subtraction_diagrams, sett.subtraction_projectors);
	}
	// Compute subtraction coefficients for G1
        subtraction_coefficients[7] =
            ComputeSubtractionCoefficients(amputated_twoq_G1_diagram, amputated_twoq_subtraction_diagrams, sett.subtraction_projectors);

        // in Qslash scheme, we enforce no mixing between representations. 
        // This means that we only do subtractions for the (8,1) operators,
        // since the subtraction operators all live in the (8,1) representation.
        // So we set the subtraction coefficients for the (27,1) and (8,8) operators to zero.
        if (sett.scheme == SchemeQslash) {
            for (int op : non_8_1_operators) {
                for (int sub = 0; sub < Nsub; ++sub) {
                    subtraction_coefficients[op][sub] = 0;
                }
            }
        }

        for (int op = 0; op < 8; ++op) {
            for (int sub = 0; sub < Nsub; ++sub) {
                jack_subtraction_coefficients[op][sub][jack] = subtraction_coefficients[op][sub];
            }
        }
	for (int op = 0; op < 7; ++op) {
	    jack_unsubtracted_chiral_twoq_greens_funcs[op][jack] = unsubtracted_chiral_twoq_greens_funcs[op].ColorTraceOverThree();
	    WilsonMatrix subtracted_chiral_twoq_greens_funcs =
		ComputeSubtractedTwoQuarkGreensFunction(unsubtracted_chiral_twoq_greens_funcs[op], amputated_twoq_subtraction_diagrams, subtraction_coefficients[op]);
	    jack_subtracted_chiral_twoq_greens_funcs[op][jack] = subtracted_chiral_twoq_greens_funcs.ColorTraceOverThree();
	}
	jack_unsubtracted_chiral_twoq_greens_funcs[7][jack] = amputated_twoq_G1_diagram.ColorTraceOverThree();
	WilsonMatrix subtracted_twoq_G1_greens_func =
	    ComputeSubtractedTwoQuarkGreensFunction(amputated_twoq_G1_diagram, amputated_twoq_subtraction_diagrams, subtraction_coefficients[7]);
	jack_subtracted_chiral_twoq_greens_funcs[7][jack] = subtracted_twoq_G1_greens_func.ColorTraceOverThree();
    }
    printf("done computing subtraction coefficients.\n");


    for (int op = 0; op < 8; ++op) {
        char op_name[128];
        if (op == 7) sprintf(op_name, "G1");
        else sprintf(op_name, "Q''_%d", op+1);
	printf("chiral basis op %s\n", op_name);

	char name[512];
	sprintf(name, "unsubtracted amputated twoq Green's function of %s", op_name);
	PrintSpinMatrixWithError(name, jack_unsubtracted_chiral_twoq_greens_funcs[op]);

	for (int sub = 0; sub < Nsub; ++sub) {
	    sprintf(name, "subtraction coefficient of %s", sett.subtraction_op_names[sub]);
	    PrintComplexWithError(name, jack_subtraction_coefficients[op][sub]);
	}

	sprintf(name, "subtracted amputated twoq Green's function of %s", op_name);
	PrintSpinMatrixWithError(name, jack_subtracted_chiral_twoq_greens_funcs[op]);

	printf("----------------------------------------\n");
    }

    return jack_subtraction_coefficients;
}


static JackknifeDatabase<Matrix<complex<double>, 8>> ComputeSubtractedProjectedGreensFuncsJackknife(
    const JackknifeDatabase<WilsonMatrix> &jack_prop1,
    const JackknifeDatabase<WilsonMatrix> &jack_prop2,
    const JackknifeDatabase<Matrix<complex<double>, 8>> &jack_unsubtracted_projected_fourq_greens_funcs_8x8,
    const array<array<JackknifeDatabase<complex<double>>, Nsub>, 8> &jack_subtraction_coefficients,
    const NPRSettings &sett)
{
    printf("loading fourq subtraction diagrams (Nsub = %d)...\n", Nsub);
    array<ConfSampleDatabase<DoubleWilsonMatrix>, Nsub> unamputated_fourq_subtraction_dbs;
    for (int sub = 0; sub < Nsub; ++sub) {
	char fourq_diagram_format[512];
	sprintf(fourq_diagram_format, "%s/fourq_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
	    sett.sub_dir, sett.subtraction_op_names[sub], sett.mom1[0], sett.mom1[1], sett.mom1[2], sett.mom1[3], sett.mom2[0], sett.mom2[1], sett.mom2[2], sett.mom2[3]);
	unamputated_fourq_subtraction_dbs[sub] =
	    ConfSampleDatabase<DoubleWilsonMatrix>::LoadBinned(BinningDoubleWilsonMatrixLoader(fourq_diagram_format), sett.confs, sett.bin_size);
    }

    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_projected_fourq_greens_funcs_8x8;
    jack_subtracted_projected_fourq_greens_funcs_8x8.Resize(sett.Njack);
#pragma omp parallel for
    for (int jack = 0; jack < sett.Njack; ++jack) {
	const vector<int> &sample = sett.jackknife_samples[jack];
	const WilsonMatrix &prop1 = jack_prop1[jack];
	const WilsonMatrix &prop2 = jack_prop2[jack];

	// Amputate the two-quark and four-quark diagrams of the subtraction operators
	array<DoubleWilsonMatrix, Nsub> amputated_fourq_subtraction_diagrams;
	for (int sub = 0; sub < Nsub; ++sub) {
	    DoubleWilsonMatrix unamputated_fourq_diagram = unamputated_fourq_subtraction_dbs[sub].MeanOnSample(sample);
	    amputated_fourq_subtraction_diagrams[sub] = Amputate(unamputated_fourq_diagram, prop1, prop2, prop1, prop2);
	}
        
	// Combine the four-quark diagrams of the subtraction operators
	// to form projected four-quark Green's functions of the subtraction operators
	array<array<complex<double>, 8>, Nsub> projected_fourq_subtraction_greens_funcs;
	for (int sub = 0; sub < Nsub; ++sub) {
            array<complex<double>, 7> seven_projected_fourq_subtraction_greens_funcs;
	    if (sett.scheme == SchemeGammaMu) {
		seven_projected_fourq_subtraction_greens_funcs = ContractionsWithG1::DoContractionsTwoQuarkOpFourQuarkExt(
		    amputated_fourq_subtraction_diagrams[sub], sett.projector_spin_color_structures);
	    } else { // scheme == SchemeQslash
		seven_projected_fourq_subtraction_greens_funcs = ContractionsWithG1::DoQslashContractionsTwoQuarkOpFourQuarkExt(
		    amputated_fourq_subtraction_diagrams[sub], sett.projector_spin_color_structures);
	    }
            for (int ext = 0; ext < 7; ++ext) projected_fourq_subtraction_greens_funcs[sub][ext] = seven_projected_fourq_subtraction_greens_funcs[ext];
	    projected_fourq_subtraction_greens_funcs[sub][7] = ContractionsWithG1::DoContractionTwoQuarkOpHFExt(
		amputated_fourq_subtraction_diagrams[sub], sett.HF_projector_spin_color_structure);
	}

	// Using the computed subtraction coefficients, subtract the contribution of
	// the subtraction operators from each projected four-quark Green's function
	// of the chiral basis four-quark operators
        jack_subtracted_projected_fourq_greens_funcs_8x8[jack] = jack_unsubtracted_projected_fourq_greens_funcs_8x8[jack];
	for (int op = 0; op < 8; ++op) {
	    for (int ext = 0; ext < 8; ++ext) {
	        for (int sub = 0; sub < Nsub; ++sub) {
		    jack_subtracted_projected_fourq_greens_funcs_8x8[jack][op][ext] -=
			jack_subtraction_coefficients[op][sub][jack] * projected_fourq_subtraction_greens_funcs[sub][ext];
		}
	    }
	}
        
	// optionally, manually set the imaginary parts of all Green's functions to zero
	if (sett.enforce_reality) {
	    ZeroOutImaginaryPart(jack_subtracted_projected_fourq_greens_funcs_8x8[jack]);
	}
    }

    PrintRealPartMatrixWithError("real part of subtracted projected fourq greens functions", jack_subtracted_projected_fourq_greens_funcs_8x8);
    PrintImaginaryPartMatrixWithError("imaginary part of subtracted projected fourq greens functions", jack_subtracted_projected_fourq_greens_funcs_8x8);

    return jack_subtracted_projected_fourq_greens_funcs_8x8;
}

template<class T>
static Matrix<T, 7> Upper7x7(const Matrix<T, 8> &m8x8)
{
    Matrix<T, 7> m7x7;
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j < 7; ++j) {
            m7x7[i][j] = m8x8[i][j];
        }
    }
    return m7x7;
}

static void ComputeZFactors(
        const JackknifeDatabase<Matrix<complex<double>, 8>> &jack_greens_funcs_8x8,
        const Matrix<complex<double>, 8> &tree_level_greens_funcs_8x8,
        JackknifeDatabase<Matrix<complex<double>, 8>> &jack_Z_8x8,
        JackknifeDatabase<Matrix<complex<double>, 7>> &jack_Z_7x7)
{
    int Njack = jack_greens_funcs_8x8.Size();
    printf("ComputeZFactors: Njack = %d\n", Njack);
    jack_Z_8x8.Resize(Njack);
    jack_Z_7x7.Resize(Njack);
    for (int jack = 0; jack < Njack; ++jack) {
        jack_Z_8x8[jack] = tree_level_greens_funcs_8x8 * jack_greens_funcs_8x8[jack].Inverse();
        jack_Z_7x7[jack] = Upper7x7(tree_level_greens_funcs_8x8) * Upper7x7(jack_greens_funcs_8x8[jack]).Inverse();
    }
}

// <G_1^lat> = k_i <O_i^lat>
// k_j = (s_i Z_ij - d_j) / (Z_G1 - s_k c_k)
// Z_ij = jack_subtracted_Zfactors_8x8[i][j]
// c_i  = jack_subtracted_Zfactors_8x8[i][7] 
// d_i  = jack_subtracted_Zfactors_8x8[7][i] 
// Z_G1 = jack_subtracted_Zfactors_8x8[7][7]
static array<complex<double>, 7> ComputeKFactors(const Matrix<complex<double>, 8> &subtracted_Zfactors_8x8)
{
    // On-shell, G_1 = s_i Q''_i at tree level.
    static const array<complex<double>, 7> s_coeffs{{ 0, 1.0, 7.0/3.0, -1.0/3.0, 1.0, 0, 0 }};
    
    array<complex<double>, 7> k_factors;
    complex<double> k_denom = subtracted_Zfactors_8x8[7][7]; // Z_G1
    for (int i = 0; i < 7; ++i) {
	k_denom -= s_coeffs[i] * subtracted_Zfactors_8x8[i][7]; // -s_i * c_i
    }
    for (int i = 0; i < 7; ++i) {
	complex<double> k_num = -subtracted_Zfactors_8x8[7][i]; // -d_i
	for (int j = 0; j < 7; ++j) {
	    k_num += s_coeffs[j] * subtracted_Zfactors_8x8[j][i]; // s_j * Z_ji
	}
	k_factors[i] = k_num / k_denom; // (s_j Z_ji - d_i) / (Z_G1 - s_k * c_k)
    }
    return k_factors;
}

// R_ij = Z_ij + c_i * k_j
static Matrix<complex<double>, 7> ComputeRMatrix(const Matrix<complex<double>, 8> &subtracted_Zfactors_8x8,
    const array<complex<double>, 7> &k_factors)
{
    Matrix<complex<double>, 7> Rmatrix;
    for (int i = 0; i < 7; ++i) {
	for (int j = 0; j < 7; ++j) {
	    Rmatrix[i][j] = subtracted_Zfactors_8x8[i][j] + subtracted_Zfactors_8x8[i][7] * k_factors[j];
	}
    }

    return Rmatrix;
}

JackknifeDatabase<Matrix<complex<double>, 7>> ComputeRMatrixJackknife(
        const JackknifeDatabase<Matrix<complex<double>, 8>> &Z_8x8,
        const JackknifeDatabase<Matrix<complex<double>, 7>> &Z_7x7)
{
    printf("doing R matrix...\n");
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_R;
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_R_minus_Z_7x7;
    array<JackknifeDatabase<complex<double>>, 7> jack_k_factors;
    int Njack = Z_8x8.Size();
    jack_R.Resize(Njack);
    jack_R_minus_Z_7x7.Resize(Njack);
    for (int op = 0; op < 7; ++op) jack_k_factors[op].Resize(Njack);
#pragma omp parallel for
    for (int jack = 0; jack < Njack; ++jack) {
	array<complex<double>, 7> k_factors = ComputeKFactors(Z_8x8[jack]);
	for (int op = 0; op < 7; ++op) {
	    jack_k_factors[op][jack] = k_factors[op];
	}

	Matrix<complex<double>, 7> R = ComputeRMatrix(Z_8x8[jack], k_factors);
	jack_R[jack] = R;
	jack_R_minus_Z_7x7[jack] = R - Z_7x7[jack];
    }
    printf("done Rmatrix.\n");


    printf("k_factors:\n");
    for (int i = 0; i < 7; ++i) {
	char name[512];
	sprintf(name, "k_factor of Q''_%d", i + 1);
	PrintComplexWithError(name, jack_k_factors[i]);
    }
    printf("\n");

    PrintRealPartMatrixWithError("real R", jack_R);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real R", jack_R);
    PrintImaginaryPartMatrixWithError("imaginary R", jack_R);

    PrintRealPartMatrixWithError("real R minus Z_7x7", jack_R_minus_Z_7x7);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real R minus Z_7x7", jack_R_minus_Z_7x7);
    PrintImaginaryPartMatrixWithError("imaginary R minus Z_7x7", jack_R_minus_Z_7x7);

    return jack_R;
}

static void BuildSubtractedFourqGreensFuncs8x8(
    JackknifeDatabase<Matrix<complex<double>, 8>> &jack_unsubtracted_fourq_greens_funcs_8x8,
    JackknifeDatabase<Matrix<complex<double>, 8>> &jack_subtracted_fourq_greens_funcs_8x8,
    NPRSettings &sett)
{
    sett.Init();

    // Compute external legs
    JackknifeDatabase<WilsonMatrix> jack_prop1, jack_prop2;
    ComputeExternalLegsJackknife(jack_prop1, jack_prop2, sett);

    // Load and amputate the four-quark diagrams of the four-quark operators and G1
    JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> jack_amputated_fourq_LR_diagrams = ComputeAmputatedFourqOpFourqDiagrams(jack_prop1, jack_prop2, sett);
    JackknifeDatabase<DoubleWilsonMatrix> jack_amputated_fourq_LR_G1_diagram = ComputeAmputatedG1FourqDiagrams(jack_prop1, jack_prop2, sett);

    // Compute unsubtracted green's functions of operators in four-quark external states
    JackknifeDatabase<Matrix<complex<double>, 7>>  jack_unsubtracted_fourq_greens_funcs_7x7 = ComputeProjectedGreensFuncsJackknife7x7(jack_amputated_fourq_LR_diagrams, sett);
    JackknifeDatabase<array<complex<double>, 7>> jack_unsubtracted_fourq_HF_greens_funcs = ComputeProjectedHFGreensFuncsJackknife(jack_amputated_fourq_LR_diagrams, sett);
    JackknifeDatabase<array<complex<double>, 8>> jack_unsubtracted_projected_G1_greens_funcs = ComputeProjectedG1GreensFuncs(jack_amputated_fourq_LR_G1_diagram, sett);

    jack_unsubtracted_fourq_greens_funcs_8x8 = 
        CombineProjectedGreensFuncsJackknife8x8(jack_unsubtracted_fourq_greens_funcs_7x7, jack_unsubtracted_fourq_HF_greens_funcs, 
                                                jack_unsubtracted_projected_G1_greens_funcs, sett);
    
    // Do subtractions
    if (sett.do_subtractions) {
        array<array<JackknifeDatabase<complex<double>>, Nsub>, 8> jack_subtraction_coefficients = ComputeSubtractionCoefficientsJackknife(jack_prop1, jack_prop2, sett);
        jack_subtracted_fourq_greens_funcs_8x8 = 
            ComputeSubtractedProjectedGreensFuncsJackknife(jack_prop1, jack_prop2, jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtraction_coefficients, sett);
    } else {
        jack_subtracted_fourq_greens_funcs_8x8 = jack_unsubtracted_fourq_greens_funcs_8x8;
    }
}


static NPRResults DoZFactors(
        const JackknifeDatabase<Matrix<complex<double>, 8>> &jack_unsubtracted_fourq_greens_funcs_8x8,
        const JackknifeDatabase<Matrix<complex<double>, 8>> &jack_subtracted_fourq_greens_funcs_8x8,
        const NPRSettings &sett)
{
    // Compute Z-factors
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_Z_8x8;
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_unsubtracted_Z_7x7;
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_Z_8x8;
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_subtracted_Z_7x7;
    ComputeZFactors(jack_unsubtracted_fourq_greens_funcs_8x8, sett.tree_level_greens_funcs_8x8, jack_unsubtracted_Z_8x8, jack_unsubtracted_Z_7x7);
    ComputeZFactors(jack_subtracted_fourq_greens_funcs_8x8, sett.tree_level_greens_funcs_8x8, jack_subtracted_Z_8x8, jack_subtracted_Z_7x7);

    PrintRealPartMatrixWithError("real unsubtracted_Z_7x7", jack_unsubtracted_Z_7x7);
    PrintRealPartMatrixWithError("real subtracted_Z_7x7", jack_subtracted_Z_7x7);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real subtracted_Z_7x7", jack_subtracted_Z_7x7);
    PrintRealPartMatrixWithError("real unsubtracted_Z_8x8", jack_unsubtracted_Z_8x8);
    PrintRealPartMatrixWithError("real subtracted_Z_8x8", jack_subtracted_Z_8x8);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real subtracted_Z_8x8", jack_subtracted_Z_8x8);
    PrintImaginaryPartMatrixWithError("imaginary unsubtracted_Z_7x7", jack_unsubtracted_Z_7x7);
    PrintImaginaryPartMatrixWithError("imaginary subtracted_Z_7x7", jack_subtracted_Z_7x7);
    PrintImaginaryPartMatrixWithError("imaginary unsubtracted_Z_8x8", jack_unsubtracted_Z_8x8);
    PrintImaginaryPartMatrixWithError("imaginary subtracted_Z_8x8", jack_subtracted_Z_8x8);

    // Compute R matrix
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_R = ComputeRMatrixJackknife(jack_subtracted_Z_8x8, jack_subtracted_Z_7x7);

    return NPRResults{ jack_subtracted_Z_7x7, jack_subtracted_Z_8x8, jack_R };
}

NPRResults NPR_SimpleG1_WithSubtractions(NPRSettings &sett)
{
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8;
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_fourq_greens_funcs_8x8;
    BuildSubtractedFourqGreensFuncs8x8(jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtracted_fourq_greens_funcs_8x8, sett);

    return DoZFactors(jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtracted_fourq_greens_funcs_8x8, sett);
}

// For use with 32^3 DSDR lattice where I have measurements of everything at two different rotated momenta
NPRResults NPR_SimpleG1_WithSubtractions_TwoMoms(NPRSettings &sett1, NPRSettings &sett2)
{
    printf("DOING MOMENTUM 1...........\n");
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8_1;
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_fourq_greens_funcs_8x8_1;
    BuildSubtractedFourqGreensFuncs8x8(jack_unsubtracted_fourq_greens_funcs_8x8_1, jack_subtracted_fourq_greens_funcs_8x8_1, sett1);
    printf("DONE MOMENTUM 1.\n");
    printf("DOING MOMENTUM 2...........\n");
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8_2;
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_fourq_greens_funcs_8x8_2;
    BuildSubtractedFourqGreensFuncs8x8(jack_unsubtracted_fourq_greens_funcs_8x8_2, jack_subtracted_fourq_greens_funcs_8x8_2, sett2);
    printf("DONE MOMENTUM 2.\n");

    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8 =
        0.5 * (jack_unsubtracted_fourq_greens_funcs_8x8_1 + jack_unsubtracted_fourq_greens_funcs_8x8_2);
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_fourq_greens_funcs_8x8 =
        0.5 * (jack_subtracted_fourq_greens_funcs_8x8_1 + jack_subtracted_fourq_greens_funcs_8x8_2);

    PrintRealPartMatrixWithError("Averaged unsubtracted green's functions real part", jack_unsubtracted_fourq_greens_funcs_8x8);
    PrintImaginaryPartMatrixWithError("Averaged unsubtracted green's functions imaginary part", jack_unsubtracted_fourq_greens_funcs_8x8);

    PrintRealPartMatrixWithError("Averaged subtracted green's functions real part", jack_subtracted_fourq_greens_funcs_8x8);
    PrintImaginaryPartMatrixWithError("Averaged subtracted green's functions imaginary part", jack_subtracted_fourq_greens_funcs_8x8);

    return DoZFactors(jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtracted_fourq_greens_funcs_8x8, sett1);
}

// For use with 24^3 lattice low scale where I have two copies of G1 measurements at rotated momenta
static void BuildSubtractedFourqGreensFuncs8x8_TwoMomsForG1(
    JackknifeDatabase<Matrix<complex<double>, 8>> &jack_unsubtracted_fourq_greens_funcs_8x8,
    JackknifeDatabase<Matrix<complex<double>, 8>> &jack_subtracted_fourq_greens_funcs_8x8,
    NPRSettings &sett,
    NPRSettings &sett2)
{
    sett.Init();
    sett2.Init();
    assert(sett.jackknife_samples.size() == sett2.jackknife_samples.size());
    assert(sett.scheme == sett2.scheme);
    assert(sett.parity == sett2.parity);
    assert(sett.qsq == sett2.qsq);

    // Compute external legs
    JackknifeDatabase<WilsonMatrix> jack_prop1, jack_prop2;
    JackknifeDatabase<WilsonMatrix> jack_prop1_s2, jack_prop2_s2;
    ComputeExternalLegsJackknife(jack_prop1, jack_prop2, sett);
    ComputeExternalLegsJackknife(jack_prop1_s2, jack_prop2_s2, sett2);

    // Load and amputate the four-quark diagrams of the four-quark operators and G1
    JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> jack_amputated_fourq_LR_diagrams = ComputeAmputatedFourqOpFourqDiagrams(jack_prop1, jack_prop2, sett);
    JackknifeDatabase<DoubleWilsonMatrix> jack_amputated_fourq_LR_G1_diagram = ComputeAmputatedG1FourqDiagrams(jack_prop1, jack_prop2, sett);
    JackknifeDatabase<DoubleWilsonMatrix> jack_amputated_fourq_LR_G1_diagram_s2 = ComputeAmputatedG1FourqDiagrams(jack_prop1_s2, jack_prop2_s2, sett2);

    // Compute unsubtracted green's functions of operators in four-quark external states
    JackknifeDatabase<Matrix<complex<double>, 7>>  jack_unsubtracted_fourq_greens_funcs_7x7 = ComputeProjectedGreensFuncsJackknife7x7(jack_amputated_fourq_LR_diagrams, sett);
    JackknifeDatabase<array<complex<double>, 7>> jack_unsubtracted_fourq_HF_greens_funcs = ComputeProjectedHFGreensFuncsJackknife(jack_amputated_fourq_LR_diagrams, sett);

    JackknifeDatabase<array<complex<double>, 8>> jack_unsubtracted_projected_G1_greens_funcs = ComputeProjectedG1GreensFuncs(jack_amputated_fourq_LR_G1_diagram, sett);
    JackknifeDatabase<array<complex<double>, 8>> jack_unsubtracted_projected_G1_greens_funcs_s2 = ComputeProjectedG1GreensFuncs(jack_amputated_fourq_LR_G1_diagram_s2, sett2);
    JackknifeDatabase<array<complex<double>, 8>> jack_unsubtracted_projected_G1_greens_funcs_avg = 
        0.5 * (jack_unsubtracted_projected_G1_greens_funcs + jack_unsubtracted_projected_G1_greens_funcs_s2);

    PrintComplexArrayWithError("Mom1 G1 projected Green's functions:", jack_unsubtracted_projected_G1_greens_funcs);
    PrintComplexArrayWithError("Mom2 G1 projected Green's functions:", jack_unsubtracted_projected_G1_greens_funcs_s2);
    PrintComplexArrayWithError("Averaged G1 projected Green's functions:", jack_unsubtracted_projected_G1_greens_funcs_avg);


    jack_unsubtracted_fourq_greens_funcs_8x8 = 
        CombineProjectedGreensFuncsJackknife8x8(jack_unsubtracted_fourq_greens_funcs_7x7, jack_unsubtracted_fourq_HF_greens_funcs, 
                                                jack_unsubtracted_projected_G1_greens_funcs_avg, sett);
    
    // Do subtractions
    if (sett.do_subtractions) {
        array<array<JackknifeDatabase<complex<double>>, Nsub>, 8> jack_subtraction_coefficients = ComputeSubtractionCoefficientsJackknife(jack_prop1, jack_prop2, sett);
        jack_subtracted_fourq_greens_funcs_8x8 = 
            ComputeSubtractedProjectedGreensFuncsJackknife(jack_prop1, jack_prop2, jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtraction_coefficients, sett);
    } else {
        jack_subtracted_fourq_greens_funcs_8x8 = jack_unsubtracted_fourq_greens_funcs_8x8;
    }
}

NPRResults NPR_SimpleG1_WithSubtractions_TwoMomsForG1(NPRSettings &sett, NPRSettings &sett2)
{
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8;
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_fourq_greens_funcs_8x8;
    BuildSubtractedFourqGreensFuncs8x8_TwoMomsForG1(jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtracted_fourq_greens_funcs_8x8, sett, sett2);

    return DoZFactors(jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtracted_fourq_greens_funcs_8x8, sett);
}


#if 0


static array<complex<double>, 7> ComputeSimplerC(
        const Matrix<complex<double>, 7> &Z_7x7,
        const array<complex<double>, 7> &HF_greens_funcs)
{
    static const complex<double> G1_HF_greens_func = 768;
    array<complex<double>, 7> c_factors = ((-1.0 / G1_HF_greens_func) * Z_7x7) * HF_greens_funcs;
    return c_factors;
}

static Matrix<complex<double>, 7> ComputeSimplerR(
        const Matrix<complex<double>, 7> &Z_7x7,
        const array<complex<double>, 7> &c_factors)
{
    Matrix<complex<double>, 7> to_invert;
    to_invert.Identity();
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j < 7; ++j) {
            to_invert[i][j] -= c_factors[i] * s_coeffs[j];
        }
    }
    Matrix<complex<double>, 7> R = to_invert.Inverse() * Z_7x7;
    return R;
}

static JackknifeDatabase<Matrix<complex<double>, 7>> ComputeSimplerRJackknife(
        const JackknifeDatabase<Matrix<complex<double>, 7> &jack_Z_7x7,
        const JackknifeDatabase<array<complex<double>, 7> jack_HF_greens_funcs)
{
    printf("doing simpler R matrix...\n");
    JackknifeDatabase<Matrix<complex<double>, 7> jack_R;
    JackknifeDatabase<Matrix<complex<double>, 7> jack_R_minus_Z_7x7;
    array<JackknifeDatabase<complex<double>, 7> jack_c_factors;
    int Njack = jack_Z_7x7.Size();
    jack_R.Resize(Njack);
    jack_R_minus_Z_7x7.Resize(Njack);
    for (int op = 0; op < 7; ++op) jack_c_factors[i].Resize(Njack);
#pragma omp parallel for
    for (int jack = 0; jack < Njack; ++jack) {
        const Matrix<complex<double>, 7> &Z_7x7 = jack_Z_7x7[jack];
        const array<complex<double>, 7> &HF_greens_funcs = jack_HF_greens_funcs[jack];

        array<complex<double>, 7> c_factors = ComputeSimplerC(Z_7x7, HF_greens_funcs);
        Matrix<complex<double>, 7> R = ComputeSimplerR(Z_7x7, c_factors);

        jack_R[jack] = R;
        jack_R_minus_Z_7x7[jack] = R - Z_7x7;
        for (int op = 0; op < 7; ++op) jack_c_factors[op][jack] = c_factors[jack];
    }


    printf("c_factors:\n");
    for (int i = 0; i < 7; ++i) {
	char name[512];
	sprintf(name, "c_factor of Q''_%d", i + 1);
	PrintComplexWithError(name, jack_c_factors[i]);
    }
    printf("\n");

    PrintRealPartMatrixWithError("real R", jack_R);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real R", jack_R);
    PrintImaginaryPartMatrixWithError("imaginary R", jack_R);

    PrintRealPartMatrixWithError("real R minus Z_7x7", jack_R_minus_Z_7x7);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real R minus Z_7x7", jack_R_minus_Z_7x7);
    PrintImaginaryPartMatrixWithError("imaginary R minus Z_7x7", jack_R_minus_Z_7x7);

    return jack_R;
}


NPRResults NPR_EvenSimplerG1_WithSubtractions(NPRSettings &sett)
{
    sett.Init();
    
    // Compute external legs
    JackknifeDatabase<WilsonMatrix> jack_prop1, jack_prop2;
    ComputeExternalLegsJackknife(jack_prop1, jack_prop2, sett);
    
    // Load and amputate the four-quark diagrams of the four-quark operators and G1
    JackknifeDatabase<array<array<DoubleWilsonMatrix, 4>, 6>> jack_amputated_fourq_LR_diagrams = ComputeAmputatedFourqOpFourqDiagrams(jack_prop1, jack_prop2, sett);

    // Do subtractions
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_subtracted_fourq_greens_funcs_8x8;
    if (sett.do_subtractions) {
        array<array<JackknifeDatabase<complex<double>>, Nsub>, 8> jack_subtraction_coefficients = ComputeSubtractionCoefficientsJackknife(jack_prop1, jack_prop2, sett);
        jack_subtracted_fourq_greens_funcs_8x8 = 
            ComputeSubtractedProjectedGreensFuncsJackknife(jack_prop1, jack_prop2, jack_unsubtracted_fourq_greens_funcs_8x8, jack_subtraction_coefficients, sett);
    } else {
        jack_subtracted_fourq_greens_funcs_8x8 = jack_unsubtracted_fourq_greens_funcs_8x8;
    }
    
    // Compute unsubtracted green's functions of operators in four-quark external states
    JackknifeDatabase<Matrix<complex<double>, 8>> jack_unsubtracted_fourq_greens_funcs_8x8 = 
        ComputeProjectedGreensFuncsJackknife(jack_amputated_fourq_LR_diagrams, jack_amputated_fourq_LR_G1_diagram, sett);
    
	// finally we get the Zfactors
	Matrix<complex<double>, 7> unsubtracted_Zfactors_7x7 =
            ComputeZ(projected_unsubtracted_chiral_fourq_greens_funcs, projected_unsubtracted_chiral_fourq_HF_greens_funcs);
	Matrix<complex<double>, 7> subtracted_Zfactors_7x7 =
            ComputeZ(projected_subtracted_chiral_fourq_greens_funcs, projected_subtracted_chiral_fourq_HF_greens_funcs);
    
        //array<complex<double>, 7> unsubtracted_Cfactors = 
        //    ComputeC(unsubtracted_Zfactors_7x7, projected_unsubtracted_chiral_fourq_HF_greens_funcs);
        array<complex<double>, 7> subtracted_Cfactors = 
            ComputeC(subtracted_Zfactors_7x7, projected_subtracted_chiral_fourq_HF_greens_funcs);
        
    Matrix<complex<double>, 7> unsubtracted_R = ComputeSimplerRJackknife(unsubtracted_Z_7x7, unsubtracted_c_factors);
    Matrix<complex<double>, 7> subtracted_R = ComputeSimplerRJackknife(subtracted_Z_7x7, subtracted_c_factors);

    NPRResults ret;
    ret.jack_Z_7x7 = jack_Z_7x7;
    // no Z_8x8 using this method
    ret.jack_R = jack_R;
    return ret;
}

#endif
