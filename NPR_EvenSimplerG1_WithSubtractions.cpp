#include "NPR_EvenSimplerG1_WithSubtractions.h"

#include "DoubleWilsonMatrix.h"
#include "util.h"
#include "NPR_Utils.h"

#include "AutogeneratedContractions_WithG1_WithSubtractions.h"

using namespace std;


#define Nsub 3

// On-shell, G_1 = k_i Q''_i at tree level.
static const array<complex<double>, 7> s_coeffs{{  
    0,
    1.0,
    7.0 / 3.0,
    -1.0 / 3.0,
    1.0,
    0,
    0
}};

static const array<complex<double>, 7> m_coeffs{{
    0,
    1,
    2,
    0,
    1,
    0,
    3
}};

// Taken from https://rbc.phys.columbia.edu/rbc_ukqcd/individual_postings/qliu/2011/k2pipiNPR/k2pipiNPR_2.pdf
// I have verified this tree level mixing matrix with a free lattice calculation.
// The Z factor matrix is given by
// Z / Zq ^ 2 = F inv(M)
// where M is the matrix of mixings(projections of amputated Green's functions)
// and F is the tree level mixing matrix below.
static const Matrix<complex<double>, 7> tree_level_mixings_7x7_gammamu = {{{
    {{{3072, 3072, 0, 0, 0, 0, 0}}},
    {{{537.6, -230.4, 1152, 0, 0, 0, 0}}},
    {{{-230.4, 537.6, 384, 0, 0, 0, 0}}},
    {{{0, 0, 0, 1152, 384, 3456, 1152}}},
    {{{0, 0, 0, 384, 1152, 1152, 3456}}},
    {{{0, 0, 0, 1152, 384, 0, 0}}},
    {{{0, 0, 0, 384, 1152, 0, }}},
}}};

static Matrix<complex<double>, 7> ComputeZ(
        const Matrix<complex<double>, 7> &greens_funcs_7x7, 
        const array<complex<double>, 7> &HF_greens_funcs)
{

    Matrix<complex<double>, 7> to_invert = greens_funcs_7x7;
    for (int op = 0; op < 7; ++op) {
        for (int ext = 0; ext < 7; ++ext) {
            to_invert[op][ext] -= m_coeffs[ext] * HF_greens_funcs[op];
        }
    }
    Matrix<complex<double>, 7> Z_7x7 = tree_level_mixings_7x7_gammamu * to_invert.Inverse();
    return Z_7x7;
}

static array<complex<double>, 7> ComputeC(
        const Matrix<complex<double>, 7> &Z_7x7,
        const array<complex<double>, 7> &HF_greens_funcs)
{
    static const complex<double> G1_HF_greens_func = 768;
    array<complex<double>, 7> c_factors = ((-1.0 / G1_HF_greens_func) * Z_7x7) * HF_greens_funcs;
    return c_factors;
}

static Matrix<complex<double>, 7> ComputeR(
        const Matrix<complex<double>, 7> &Z_7x7,
        const array<complex<double>, 7> &c_factors)
{
    Matrix<complex<double>, 7> to_invert;
    to_invert.Identity();
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j < 7; ++j) {
            to_invert[i][j] -= c_factors[i] * s_coeffs[j];
        }
    }
    Matrix<complex<double>, 7> R = to_invert.Inverse() * Z_7x7;
    return R;
}

static void NPR_EvenSimplerG1_WithSubtractions(
    const char* dir,
    const char* sub_dir,
    const vector<int> &confs,
    const int mom1[4],
    const int mom2[4],
    const int Ls[4],
    const Parity parity,
    const int bin_size)
{
    printf("\n------------- NPR_EvenSimplerG1_WithSubtractions start ---------------\n\n");

    printf("s_coeffs:\n");
    for (int i = 0; i < 7; ++i) {
	printf("s[i] = %e + i %e\n", s_coeffs[i].real(), s_coeffs[i].imag());
    }
    printf("m_coeffs:\n");
    for (int i = 0; i < 7; ++i) {
	printf("m[i] = %e + i %e\n", m_coeffs[i].real(), m_coeffs[i].imag());
    }

    const bool enforce_reality = false;
    printf("enforce_reality = %d\n", enforce_reality);

    double p1[4], p2[4], q[4];
    double qsq = 0;
    for (int mu = 0; mu < 4; ++mu) {
	p1[mu] = 2 * PI * mom1[mu] / Ls[mu];
	p2[mu] = 2 * PI * mom2[mu] / Ls[mu];
	q[mu] = p1[mu] - p2[mu];
	qsq += q[mu] * q[mu];
    }

    array<const char*, Nsub> subtraction_op_names;
    array<SpinMatrix, Nsub> subtraction_projectors;
    if (parity == POSITIVE_PARITY) {
	subtraction_op_names = array<const char*, Nsub>{{ "scalar", "forward_covariant_dslash", "backward_covariant_dslash" }};
	subtraction_projectors = array<SpinMatrix, Nsub>{{ SpinMatrix::One(), SpinMatrix::Slash(p2), SpinMatrix::Slash(p1) }};
    } else {
        subtraction_op_names = array<const char*, Nsub>{{ "pseudoscalar", "forward_covariant_dslash_g5", "backward_covariant_dslash_g5" }};
	subtraction_projectors = array<SpinMatrix, Nsub>{{ SpinMatrix::Gamma5(), SpinMatrix::Slash(p2) * SpinMatrix::Gamma5(), SpinMatrix::Slash(p1) * SpinMatrix::Gamma5() }};
    }

    const int Nconf = confs.size();
    printf("Nconf = %d\n", Nconf);
    printf("bin_size = %d\n", bin_size);
    assert((Nconf % bin_size) == 0);
    const int Nbins = Nconf / bin_size;
    printf("Nbins = %d\n", Nbins);

    //const bool parity_covariant = true;
    //const char* pc_str = (parity_covariant ? "" : "_NON_PARITY_COVARIANT");

    const bool do_disconnected = true;
    const bool do_subtractions = true;
    if (do_subtractions) assert(do_disconnected);

    if (!do_subtractions) printf("NOT GOING TO DO SUBTRACTIONS!\n");

    // Load external legs
    printf("loading external legs...\n");
    char prop1_format[512];
    char prop2_format[512];
    sprintf(prop1_format, "%s/external_leg_p%d_%d_%d_%d_traj%%d.dat", dir, mom1[0], mom1[1], mom1[2], mom1[3]);
    sprintf(prop2_format, "%s/external_leg_p%d_%d_%d_%d_traj%%d.dat", dir, mom2[0], mom2[1], mom2[2], mom2[3]);

    ConfSampleDatabase<WilsonMatrix> prop1_db = ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(prop1_format), confs, bin_size);
    ConfSampleDatabase<WilsonMatrix> prop2_db = ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(prop2_format), confs, bin_size);

    // Load unamputated VA diagrams

    printf("loading VA fourq diagrams (and computing LR diagrams)...\n");
    array<array<ConfSampleDatabase<DoubleWilsonMatrix>, 4>, 6> unamputated_fourq_LR_diagram_dbs;
    for (int diagram = 0; diagram < 6; ++diagram) {
	array<ConfSampleDatabase<DoubleWilsonMatrix>, 4> unamputated_fourq_VA_diagram_dbs;
	for (int va = 0; va < 4; ++va) {
	    char fourq_diagram_format[512];
	    sprintf(fourq_diagram_format, "%s/fourq_%s_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
		dir, diagram_names[diagram], VA_names[va], mom1[0], mom1[1], mom1[2], mom1[3], mom2[0], mom2[1], mom2[2], mom2[3]);
	    unamputated_fourq_VA_diagram_dbs[va] =
		ConfSampleDatabase<DoubleWilsonMatrix>::LoadBinned(BinningDoubleWilsonMatrixLoader(fourq_diagram_format), confs, bin_size);
	}
	unamputated_fourq_LR_diagram_dbs[diagram] = MakeLRDiagrams<DoubleWilsonMatrix>(unamputated_fourq_VA_diagram_dbs, parity);
    }

    printf("loading VA twoq diagrams (and computing LR diagrams)...\n");
    array<array<ConfSampleDatabase<WilsonMatrix>, 4>, 6> unamputated_twoq_LR_diagram_dbs;
    for (int diagram = 2 /* fully connected doesn't have twoq diagrams */; diagram < 6; ++diagram) {
	array<ConfSampleDatabase<WilsonMatrix>, 4> unamputated_twoq_VA_diagram_dbs;
	for (int va = 0; va < 4; ++va) {
	    char twoq_diagram_format[512];
	    sprintf(twoq_diagram_format, "%s/twoq_%s_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
		dir, diagram_names[diagram], VA_names[va], mom1[0], mom1[1], mom1[2], mom1[3], mom2[0], mom2[1], mom2[2], mom2[3]);
	    unamputated_twoq_VA_diagram_dbs[va] =
		ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(twoq_diagram_format), confs, bin_size);
	}
	unamputated_twoq_LR_diagram_dbs[diagram] = MakeLRDiagrams<WilsonMatrix>(unamputated_twoq_VA_diagram_dbs, parity);
    }

    printf("loading fourq and twoq subtraction diagrams (Nsub = %d)...\n", Nsub);
    array<ConfSampleDatabase<DoubleWilsonMatrix>, Nsub> unamputated_fourq_subtraction_dbs;
    array<ConfSampleDatabase<WilsonMatrix>, Nsub> unamputated_twoq_subtraction_dbs;
    for (int sub = 0; sub < Nsub; ++sub) {
	char fourq_diagram_format[512];
	sprintf(fourq_diagram_format, "%s/fourq_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.bin",
	    sub_dir, subtraction_op_names[sub], mom1[0], mom1[1], mom1[2], mom1[3], mom2[0], mom2[1], mom2[2], mom2[3]);
	unamputated_fourq_subtraction_dbs[sub] =
	    ConfSampleDatabase<DoubleWilsonMatrix>::LoadBinned(BinningDoubleWilsonMatrixLoader(fourq_diagram_format), confs, bin_size);

	char twoq_diagram_format[512];
	sprintf(twoq_diagram_format, "%s/twoq_%s_pa%d_%d_%d_%d_pb%d_%d_%d_%d_traj%%d.dat",
	    sub_dir, subtraction_op_names[sub], mom1[0], mom1[1], mom1[2], mom1[3], mom2[0], mom2[1], mom2[2], mom2[3]);
	unamputated_twoq_subtraction_dbs[sub] =
	    ConfSampleDatabase<WilsonMatrix>::LoadBinned(BinningWilsonMatrixLoader(twoq_diagram_format), confs, bin_size);
    }

    if (!do_disconnected) {
	printf("do_disconnected is FALSE, so zeroing disconnected diagrams\n");
	for (int diagram = 0; diagram < 6; ++diagram) {
	    if (diagram == FULLY_CONNECTED_COLOR_DIAG || diagram == FULLY_CONNECTED_COLOR_MIXED) continue;
	    for (int lr = 0; lr < 4; ++lr) {
		Zero(unamputated_fourq_LR_diagram_dbs[diagram][lr]);
	    }
	}
    }


    array<DoubleWilsonMatrix, 7> projector_spin_color_structures; 
    projector_spin_color_structures = BuildProjectorSpinColorStructures(parity);
    DoubleWilsonMatrix HF_projector_spin_color_structure = BuildHFProjectorSpinColorStructure(parity);

    printf("doing jackknife computations...\n");
    vector<vector<int>> jackknife_samples = MakeJackknifeSamples(Nbins, 1);
    const int Njack = jackknife_samples.size();
    printf("Njack = %d\n", Njack);

    JackknifeDatabase<Matrix<complex<double>, 7>> jack_unsubtracted_Zfactors_7x7;
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_subtracted_Zfactors_7x7;
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_Rmatrix;
    JackknifeDatabase<Matrix<complex<double>, 7>> jack_Rmatrix_minus_Zfactors_7x7;
    array<array<JackknifeDatabase<complex<double>>, Nsub>, 7> jack_subtraction_coefficients;
    array<JackknifeDatabase<SpinMatrix>, 7> jack_unsubtracted_chiral_twoq_greens_funcs;
    array<JackknifeDatabase<SpinMatrix>, 7> jack_subtracted_chiral_twoq_greens_funcs;
    array<JackknifeDatabase<complex<double>>, 7> jack_unsubtracted_chiral_HF_greens_funcs;
    array<JackknifeDatabase<complex<double>>, 7> jack_subtracted_chiral_HF_greens_funcs;

    jack_unsubtracted_Zfactors_7x7.Resize(Njack);
    jack_subtracted_Zfactors_7x7.Resize(Njack);
    jack_Rmatrix.Resize(Njack);
    jack_Rmatrix_minus_Zfactors_7x7.Resize(Njack);
    for (int op = 0; op < 7; ++op) {
	jack_unsubtracted_chiral_twoq_greens_funcs[op].Resize(Njack);
	jack_subtracted_chiral_twoq_greens_funcs[op].Resize(Njack);
	for (int sub = 0; sub < Nsub; ++sub) {
	    jack_subtraction_coefficients[op][sub].Resize(Njack);
	}
    }
    for (int op = 0; op < 7; ++op) {
	jack_unsubtracted_chiral_HF_greens_funcs[op].Resize(Njack);
	jack_subtracted_chiral_HF_greens_funcs[op].Resize(Njack);
    }

#pragma omp parallel for
    for (unsigned jack = 0; jack < jackknife_samples.size(); ++jack) {
	const vector<int> &sample = jackknife_samples[jack];

	WilsonMatrix prop1 = prop1_db.MeanOnSample(sample);
	WilsonMatrix prop2 = prop2_db.MeanOnSample(sample);

	// Amputate the two-quark diagrams of the basic four-quark operators
	array<array<WilsonMatrix, 4>, 6> amputated_twoq_LR_diagrams;
	for (int diagram = 2 /*note*/; diagram < 6; ++diagram) {
	    for (int lr = 0; lr < 4; ++lr) {
		WilsonMatrix unamputated_diagram = unamputated_twoq_LR_diagram_dbs[diagram][lr].MeanOnSample(sample);
		amputated_twoq_LR_diagrams[diagram][lr] = Amputate(unamputated_diagram, prop1, prop2);
	    }
	}

	// Combine the diagrams of the basic operators to get the two-quark Green's
	// functions of the chiral basis four-quark operators
	array<WilsonMatrix, 7> unsubtracted_chiral_twoq_greens_funcs =
	    ContractionsWithG1::DoContractionsFourQuarkOpTwoQuarkExt(amputated_twoq_LR_diagrams);

	// Amputate the two-quark and four-quark diagrams of the subtraction operators
	array<DoubleWilsonMatrix, Nsub> amputated_fourq_subtraction_diagrams;
	array<WilsonMatrix, Nsub> amputated_twoq_subtraction_diagrams;
	for (int sub = 0; sub < Nsub; ++sub) {
	    DoubleWilsonMatrix unamputated_fourq_diagram = unamputated_fourq_subtraction_dbs[sub].MeanOnSample(sample);
	    amputated_fourq_subtraction_diagrams[sub] = Amputate(unamputated_fourq_diagram, prop1, prop2, prop1, prop2);

	    WilsonMatrix unamputated_twoq_diagram = unamputated_twoq_subtraction_dbs[sub].MeanOnSample(sample);
	    amputated_twoq_subtraction_diagrams[sub] = Amputate(unamputated_twoq_diagram, prop1, prop2);
	}

	// Compute subtraction coefficients for the chiral-basis four-quark operators
        assert(do_subtractions);
	array<array<complex<double>, Nsub>, 7> subtraction_coefficients;
	for (int op = 0; op < 7; ++op) {
	    subtraction_coefficients[op] = ComputeSubtractionCoefficients(unsubtracted_chiral_twoq_greens_funcs[op],
		amputated_twoq_subtraction_diagrams, subtraction_projectors);
	}

	// Amputate the four-quark diagrams of the basic four-quark operators
	array<array<DoubleWilsonMatrix, 4>, 6> amputated_fourq_LR_diagrams;
	for (int diagram = 0; diagram < 6; ++diagram) {
	    for (int lr = 0; lr < 4; ++lr) {
		DoubleWilsonMatrix unamputated_diagram = unamputated_fourq_LR_diagram_dbs[diagram][lr].MeanOnSample(sample);
		amputated_fourq_LR_diagrams[diagram][lr] = Amputate(unamputated_diagram, prop1, prop2, prop1, prop2);
	    }
	}

	// Compute the projected four-quark Green's functions of all eight operators in the standard 7 external states
	Matrix<complex<double>, 7> projected_unsubtracted_chiral_fourq_greens_funcs; 
	projected_unsubtracted_chiral_fourq_greens_funcs =
	    ContractionsWithG1::DoContractionsFourQuarkOpFourQuarkExt(amputated_fourq_LR_diagrams, projector_spin_color_structures);

	// Compute the projected four-quark Green's functions of all eight operators in the HF external state
	array<complex<double>, 7> projected_unsubtracted_chiral_fourq_HF_greens_funcs =
	    ContractionsWithG1::DoContractionsFourQuarkOpHFExt(amputated_fourq_LR_diagrams, HF_projector_spin_color_structure);

	// Combine the four-quark diagrams of the subtraction operators
	// to form projected four-quark Green's functions of the subtraction operators
	array<array<complex<double>, 7>, Nsub> projected_fourq_subtraction_greens_funcs;
	array<complex<double>, Nsub> projected_fourq_subtraction_HF_greens_funcs;
	for (int sub = 0; sub < Nsub; ++sub) {
	    projected_fourq_subtraction_greens_funcs[sub] = ContractionsWithG1::DoContractionsTwoQuarkOpFourQuarkExt(
		amputated_fourq_subtraction_diagrams[sub], projector_spin_color_structures);
	    projected_fourq_subtraction_HF_greens_funcs[sub] = ContractionsWithG1::DoContractionTwoQuarkOpHFExt(
		amputated_fourq_subtraction_diagrams[sub], HF_projector_spin_color_structure);
	}

	// Using the computed subtraction coefficients, subtract the contribution of
	// the subtraction operators from each projected four-quark Green's function
	// of the chiral basis four-quark operators
	Matrix<complex<double>, 7> projected_subtracted_chiral_fourq_greens_funcs = projected_unsubtracted_chiral_fourq_greens_funcs;
	array<complex<double>, 7> projected_subtracted_chiral_fourq_HF_greens_funcs = projected_unsubtracted_chiral_fourq_HF_greens_funcs;
	for (int op = 0; op < 7; ++op) {
	    for (int sub = 0; sub < Nsub; ++sub) {
		for (int ext = 0; ext < 7; ++ext) {
		    projected_subtracted_chiral_fourq_greens_funcs[op][ext] -=
			subtraction_coefficients[op][sub] * projected_fourq_subtraction_greens_funcs[sub][ext];
		}
		projected_subtracted_chiral_fourq_HF_greens_funcs[op] -=
		    subtraction_coefficients[op][sub] * projected_fourq_subtraction_HF_greens_funcs[sub];
	    }
	}

	// optionally, manually set the imaginary parts of all Green's functions to zero
	if (enforce_reality) {
	    ZeroOutImaginaryPart(projected_unsubtracted_chiral_fourq_greens_funcs);
	    ZeroOutImaginaryPart(projected_subtracted_chiral_fourq_greens_funcs);
	}

	// finally we get the Zfactors
	Matrix<complex<double>, 7> unsubtracted_Zfactors_7x7 =
            ComputeZ(projected_unsubtracted_chiral_fourq_greens_funcs, projected_unsubtracted_chiral_fourq_HF_greens_funcs);
	Matrix<complex<double>, 7> subtracted_Zfactors_7x7 =
            ComputeZ(projected_subtracted_chiral_fourq_greens_funcs, projected_subtracted_chiral_fourq_HF_greens_funcs);

        //array<complex<double>, 7> unsubtracted_Cfactors = 
        //    ComputeC(unsubtracted_Zfactors_7x7, projected_unsubtracted_chiral_fourq_HF_greens_funcs);
        array<complex<double>, 7> subtracted_Cfactors = 
            ComputeC(subtracted_Zfactors_7x7, projected_subtracted_chiral_fourq_HF_greens_funcs);

        //Matrix<complex<double>, 7> unsubtracted_Rmatrix = ComputeR(unsubtracted_Zfactors_7x7, unsubtracted_Cfactors);
        Matrix<complex<double>, 7> subtracted_Rmatrix = ComputeR(subtracted_Zfactors_7x7, subtracted_Cfactors);

	jack_unsubtracted_Zfactors_7x7[jack] = unsubtracted_Zfactors_7x7;
	jack_subtracted_Zfactors_7x7[jack] = subtracted_Zfactors_7x7;

	// other interesting info

	for (int op = 0; op < 7; ++op) {
	    jack_unsubtracted_chiral_twoq_greens_funcs[op][jack] = unsubtracted_chiral_twoq_greens_funcs[op].ColorTraceOverThree();

	    WilsonMatrix subtracted_chiral_twoq_greens_funcs =
		ComputeSubtractedTwoQuarkGreensFunction(unsubtracted_chiral_twoq_greens_funcs[op],
		amputated_twoq_subtraction_diagrams, subtraction_coefficients[op]);
	    jack_subtracted_chiral_twoq_greens_funcs[op][jack] = subtracted_chiral_twoq_greens_funcs.ColorTraceOverThree();

	    for (int sub = 0; sub < Nsub; ++sub) {
		jack_subtraction_coefficients[op][sub][jack] = subtraction_coefficients[op][sub];
	    }
	}

	for (int op = 0; op < 7; ++op) {
	    jack_unsubtracted_chiral_HF_greens_funcs[op][jack] = projected_unsubtracted_chiral_fourq_HF_greens_funcs[op];
	    jack_subtracted_chiral_HF_greens_funcs[op][jack] = projected_subtracted_chiral_fourq_HF_greens_funcs[op];
	}

	jack_Rmatrix[jack] = subtracted_Rmatrix;
    }

    printf("done jackknife computations.\n");

    for (int op = 0; op < 7; ++op) {
	printf("chiral basis op Q''_%d\n", op + 1);

	char name[512];
	sprintf(name, "unsubtracted amputated twoq Green's function of Q''_%d", op + 1);
	PrintSpinMatrixWithError(name, jack_unsubtracted_chiral_twoq_greens_funcs[op]);

	for (int sub = 0; sub < Nsub; ++sub) {
	    sprintf(name, "subtraction coefficient of %s", subtraction_op_names[sub]);
	    PrintComplexWithError(name, jack_subtraction_coefficients[op][sub]);
	}

	sprintf(name, "subtracted amputated twoq Green's function of Q''_%d", op + 1);
	PrintSpinMatrixWithError(name, jack_subtracted_chiral_twoq_greens_funcs[op]);

	printf("----------------------------------------\n");
    }

    Matrix<complex<double>, 7> unsubtracted_Zfactors_7x7 = jack_unsubtracted_Zfactors_7x7.CentralValue();
    Matrix<complex<double>, 7> unsubtracted_Zfactor_7x7_errs = jack_unsubtracted_Zfactors_7x7.Error();
    unsubtracted_Zfactors_7x7.Print("unsubtracted_Zfactors_7x7");
    unsubtracted_Zfactor_7x7_errs.Print("unsubtracted_Zfactor_7x7_errs");

    PrintRealPartMatrixWithError("real unsubtracted_Zfactors_7x7", jack_unsubtracted_Zfactors_7x7);
    PrintRealPartMatrixWithError("real subtracted_Zfactors_7x7", jack_subtracted_Zfactors_7x7);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real subtracted_Zfactors_7x7", jack_subtracted_Zfactors_7x7);

    PrintImaginaryPartMatrixWithError("imaginary unsubtracted_Zfactors_7x7", jack_unsubtracted_Zfactors_7x7);
    PrintImaginaryPartMatrixWithError("imaginary subtracted_Zfactors_7x7", jack_subtracted_Zfactors_7x7);

    printf("\n\n");
    PrintComplexArrayWithError("projection of unsubtracted Q''i ops onto HF", jack_unsubtracted_chiral_HF_greens_funcs);
    PrintComplexArrayWithError("projection of subtracted Q''i ops onto HF", jack_subtracted_chiral_HF_greens_funcs);

    PrintRealPartMatrixWithError("real Rmatrix", jack_Rmatrix);
    LatexPrintRealPartMatrixWithErrorEnforcingRepresentations("real Rmatrix", jack_Rmatrix);
    PrintImaginaryPartMatrixWithError("imaginary Rmatrix", jack_Rmatrix);

    printf("\n------------- NPR_EvenSimplerG1_WithSubtractions end ---------------\n\n");
}

void NPR_EvenSimplerG1_WithSubtractions_32cubed()
{
    const char* dir = "/home/gregm/fitting/NPR/G1_NPR/data/DSDR_b1.75_ms0.045_mu0.001_32x64x32/zbai_NPR_data_5hits_Mobius_converted";
    const char* sub_dir = "/home/gregm/fitting/NPR/G1_NPR/data/DSDR_b1.75_ms0.045_mu0.001_32x64x32/justG1_NPR_mass0.0100";
    vector<int> confs;
    for (int conf = 1066; conf <= 2166 /*2170*/; conf += 4) confs.push_back(conf);
    const int mom1[] = { -4, -2, 2, 0 };
    const int mom2[] = { 0, -2, 4, -4 };
    int Ls[] = { 32, 32, 32, 64 };
    const Parity parity = NEGATIVE_PARITY;
    const int bin_size = 2;

    return NPR_EvenSimplerG1_WithSubtractions(dir, sub_dir, confs, mom1, mom2, Ls, parity, bin_size);
}


